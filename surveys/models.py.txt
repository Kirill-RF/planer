# surveys/models.py
import os
import re
import tempfile
import pandas as pd
from django.db import models
from django.shortcuts import render, redirect
from django.core.validators import FileExtensionValidator
from django.contrib import messages
from django.shortcuts import get_object_or_404
# from .models import Survey, Question, Option, Client, Employee, Response, Holding
from collections import defaultdict

# Типы вопросов
QUESTION_TYPES = (
    ('text', 'Текст'),
    ('single_select', 'Список (один выбор)'),
    ('multi_select', 'Список (множественный выбор)'),
    ('checkbox', 'Чекбоксы (множественный)'),
    ('radio', 'Радиокнопки (один)'),
    ('photo', 'Фото'),
)

class Survey(models.Model):
    """Анкета"""
    title = models.CharField(max_length=255, verbose_name="Название анкеты")
    target_count = models.PositiveIntegerField(
        null=True,
        blank=True,
        verbose_name="План (мин. кол-во заполнений)",
        help_text="Оставьте пустым для '--' (любое количество)"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=True)

    def __str__(self):
        return self.title

    class Meta:
        verbose_name = "Анкета"
        verbose_name_plural = "Анкеты"


class Question(models.Model):
    """Вопрос в анкете"""
    survey = models.ForeignKey(Survey, on_delete=models.CASCADE, related_name='questions')
    text = models.CharField(max_length=500, verbose_name="Текст вопроса")
    question_type = models.CharField(max_length=20, choices=QUESTION_TYPES, verbose_name="Тип вопроса")
    required = models.BooleanField(default=True)

    def __str__(self):
        return f"{self.text} ({self.question_type})"

    class Meta:
        verbose_name = "Вопрос"
        verbose_name_plural = "Вопросы"


class Option(models.Model):
    """Вариант ответа (для чекбоксов, радио и select)"""
    question = models.ForeignKey(Question, on_delete=models.CASCADE, related_name='options')
    text = models.CharField(max_length=200)

    def __str__(self):
        return self.text

    class Meta:
        verbose_name = "Вариант ответа"
        verbose_name_plural = "Варианты ответов"


class Holding(models.Model):
    name = models.CharField(max_length=255, unique=True, verbose_name="Название холдинга")

    def __str__(self):
        return self.name

    class Meta:
        verbose_name = "Холдинг"
        verbose_name_plural = "Холдинги"


class Employee(models.Model):
    full_name = models.CharField(max_length=255, verbose_name="ФИО сотрудника")
    position = models.CharField(max_length=200, blank=True)

    def __str__(self):
        return self.full_name

    class Meta:
        verbose_name = "Сотрудник"
        verbose_name_plural = "Сотрудники"


class Client(models.Model):
    full_name = models.CharField(max_length=255, verbose_name="ФИО клиента / Название компании")
    phone = models.CharField(max_length=20, blank=True)
    email = models.EmailField(blank=True)
    holding = models.ForeignKey(Holding, on_delete=models.SET_NULL, null=True, blank=True, verbose_name="Холдинг")
    employee = models.ForeignKey(Employee, on_delete=models.SET_NULL, null=True, blank=True, verbose_name="Сотрудник")

    def __str__(self):
        return self.full_name

    class Meta:
        verbose_name = "Клиент"
        verbose_name_plural = "Клиенты"


class ClientAssignment(models.Model):
    """Закрепление клиента за сотрудником"""
    client = models.OneToOneField(Client, on_delete=models.CASCADE)
    employee = models.ForeignKey(Employee, on_delete=models.CASCADE)
    assigned_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.client} → {self.employee}"

    class Meta:
        verbose_name = "Назначение клиента"
        verbose_name_plural = "Назначения клиентов"


class Response(models.Model):
    """Ответ на вопрос анкеты"""
    survey = models.ForeignKey(Survey, on_delete=models.CASCADE)
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    client = models.ForeignKey(Client, on_delete=models.CASCADE)
    employee = models.ForeignKey(Employee, on_delete=models.CASCADE)
    submitted_at = models.DateTimeField(auto_now_add=True)

    # Текстовый ответ (для text, или как fallback)
    text_answer = models.TextField(blank=True, null=True)

    # Для фото
    photo = models.ImageField(upload_to='responses/photos/', blank=True, null=True)

    # Для выбора варианта (checkbox/radio/select)
    selected_options = models.ManyToManyField(Option, blank=True)

    def __str__(self):
        return f"Ответ от {self.employee} по анкете {self.survey}"

    class Meta:
        verbose_name = "Ответ"
        verbose_name_plural = "Ответы"
        
def normalize_company_name(name: str) -> str:
    """Приводит название компании к стандартному виду"""
    if not name:
        return ""
    name = re.sub(r'\s+', ' ', name.strip())
    for abbr in ['ООО', 'ИП', 'ЗАО', 'ОАО', 'АО', 'ПАО', 'НКО']:
        name = re.sub(rf'\b{abbr.lower()}\b', abbr, name, flags=re.IGNORECASE)
    return name

def normalize_phone(phone):
    """Возвращает '+7XXXXXXXXXX' или None"""
    if not phone:
        return None
    cleaned = re.sub(r'[^\d+]', '', str(phone))
    if cleaned.startswith('8'):
        cleaned = '+7' + cleaned[1:]
    elif cleaned.startswith('7') and not cleaned.startswith('+7'):
        cleaned = '+' + cleaned
    elif not cleaned.startswith('+7'):
        return None
    if len(cleaned) == 12:
        return cleaned
    return None

def upload_clients(request):
    if request.method == 'POST':
        if 'excel_file' in request.FILES and 'preview' in request.POST:
            # Этап 1: Просмотр
            file = request.FILES['excel_file']
            try:
                with tempfile.NamedTemporaryFile(delete=False, suffix='.xlsx') as tmp:
                    for chunk in file.chunks():
                        tmp.write(chunk)
                    tmp_path = tmp.name

                df = pd.read_excel(tmp_path)
                if 'full_name' not in df.columns:
                    os.unlink(tmp_path)
                    messages.error(request, "Файл должен содержать столбец 'full_name'")
                    return render(request, 'surveys/upload_clients.html')

                preview_data = []
                for _, row in df.iterrows():
                    full_name_raw = row.get('full_name', '')
                    full_name = normalize_company_name(str(full_name_raw))
                    phone_raw = row.get('phone')
                    phone = normalize_phone(phone_raw)
                    email = str(row.get('email', '')).strip()
                    if email == 'nan' or not email:
                        email = ''
                    holding_name = str(row.get('holding', '')).strip() or None
                    employee_name = str(row.get('employee_full_name', '')).strip() or None

                    errors = []
                    if not full_name:
                        errors.append("Пустое имя/название")
                    if phone_raw and not phone:
                        errors.append(f"Неверный телефон: {phone_raw}")
                    if email and '@' not in email:
                        errors.append(f"Неверный email: {email}")

                    preview_data.append({
                        'full_name': full_name,
                        'phone': phone,
                        'email': email,
                        'holding': holding_name,
                        'employee_full_name': employee_name,
                        'errors': errors,
                        'is_valid': len(errors) == 0
                    })

                valid_count = sum(1 for r in preview_data if r['is_valid'])
                request.session['tmp_excel_path'] = tmp_path
                return render(request, 'surveys/upload_clients.html', {
                    'preview_data': preview_data,
                    'valid_count': valid_count,
                    'invalid_count': len(preview_data) - valid_count,
                })

            except Exception as e:
                messages.error(request, f"Ошибка при анализе файла: {e}")
                return render(request, 'surveys/upload_clients.html')

        elif 'confirm_upload' in request.POST:
            # Этап 2: Подтверждение и сохранение
            tmp_path = request.session.get('tmp_excel_path')
            if not tmp_path or not os.path.exists(tmp_path):
                messages.error(request, "Файл устарел. Загрузите заново.")
                return redirect('upload_clients')

            try:
                df = pd.read_excel(tmp_path)
                created = updated = 0
                for _, row in df.iterrows():
                    full_name = normalize_company_name(str(row.get('full_name', '')))
                    if not full_name:
                        continue

                    # Холдинг
                    holding = None
                    holding_name = str(row.get('holding', '')).strip()
                    if holding_name:
                        holding, _ = Holding.objects.get_or_create(name=holding_name)

                    # Сотрудник
                    employee = None
                    emp_name = str(row.get('employee_full_name', '')).strip()
                    if emp_name:
                        try:
                            employee = Employee.objects.get(full_name=emp_name)
                        except Employee.DoesNotExist:
                            pass  # или создать нового

                    # Телефон и email
                    phone = normalize_phone(row.get('phone'))
                    email = str(row.get('email', '')).strip()
                    if email == 'nan' or not email:
                        email = ''

                    obj, created_flag = Client.objects.update_or_create(
                        full_name=full_name,
                        defaults={
                            'phone': phone or '',
                            'email': email,
                            'holding': holding,
                            'employee': employee,
                        }
                    )
                    if created_flag:
                        created += 1
                    else:
                        updated += 1

                messages.success(request, f"Загружено: {created} новых, {updated} обновлено.")
            except Exception as e:
                messages.error(request, f"Ошибка при сохранении: {e}")
            finally:
                if os.path.exists(tmp_path):
                    os.unlink(tmp_path)
                request.session.pop('tmp_excel_path', None)

            return redirect('upload_clients')

    return render(request, 'surveys/upload_clients.html')